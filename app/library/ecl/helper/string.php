<?php
/**
 * String helper class
 *
 * @package  Ecl
 * @static
 * @version  1.3.0
 */
class Ecl_Helper_String {

	// Constants
	const CHARS_ALPHA       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
	const CHARS_ALPHANUM    = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	const CHARS_FOLDERNAME  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
	const CHARS_COMMON      = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`~!@#$%^&*()_+=-,.<>?/|;:\\' \\r\n\t";
	const CHARS_UUID        = '0123456789ABCDEF-';



	/**
	 * Constructor
	 */
	private function __construct() {
	}// /method



/* --------------------------------------------------------------------------------
 * Public Methods
 */



	/**
	 * Create a query-string style key=value&key=value string from the given assoc-array.
	 *
	 * @param  array  $array  Assoc-array of key-value pairs.
	 * @param  string  $outer_separator  (optional) The string that separates the key-value pairs. (default: '&amp;')
	 * @param  string  $inner_separator  (optional) The string that separates the key and value. (default: '=')
	 *
	 * @return  string  The resulting querystring.
	 */
	public static function buildQuerystring($array, $outer_separator = '&amp', $inner_separator = '=') {
		if (!is_array($array)) { return ''; }

		$qs = '';
		$first = true;
		foreach($array as $k => $v) {
			if ($first) {
				$first = false;
			} else {
				$qs .= $outer_separator;
			}
			if (is_array($v)) {
				$sub_first = true;
				foreach($v as $i => $value) {
					if ($sub_first) {
						$sub_first = false;
					} else {
						$qs .= $outer_separator;
					}
					$qs .= urlencode($k).'[]'. $inner_separator . urlencode($value);
				}
			} else {
				$qs .= urlencode($k).'='.urlencode($v);
			}
		}
		return $qs;
	}// /method



	/**
	 * Build a URL from the given pieces.
	 *
	 * Pieces should be of the same type as those generated by PHP's parse_url() function.
	 * Valid array keys are: 'scheme', 'user', 'pass', 'host', 'port', 'path', 'query', 'fragment'.
	 *
	 * @param  array  $url_sections  Assoc-array of URL pieces.
	 *
	 * @return  mixed  The completed url. On fail, null.
	 */
	public static function buildUrl($url_sections) {
		if (!is_array($url_sections)) { return null; }

		$url = null;

		// if it's a mailto URL..
		if (isset($url_sections['scheme'])) {
			$url = (strtolower($url_sections['scheme'])=='mailto') ? 'mailto:' : $url_sections['scheme'] .'://' ;
		}
		$url .= (isset($url_sections['user'])) ? $url_sections['user'] . ':' : '';
		$url .= (isset($url_sections['pass'])) ? $url_sections['pass'] . '@' : '';
		$url .= (isset($url_sections['host'])) ? $url_sections['host'] : '';
		$url .= (isset($url_sections['port'])) ? ':'.$url_sections['port'] : '';
		$url .= (isset($url_sections['path'])) ? $url_sections['path'] : '';
		$url .= (isset($url_sections['query'])) ? '?'. $url_sections['query'] : '';
		$url .= (isset($url_sections['fragment'])) ? '#'. $url_sections['fragment'] : '';
		return $url;
	}// /method



	/**
	 * Clean the string of non-standard control characters (including url encoded control chars).
	 *
	 * Removes all chars below ASCII 32, except Tab (9), New line (10) and Carriage Return (13).
	 *
	 * @param  string  $string  The string to clean.
	 *
	 * @return  string  The cleaned string.
	 */
	public static function cleanString($string) {
		do {
			$string = preg_replace('/(%0[0-8bcef]|%1[0-9a-f]|[\x00-\x08]|[\x0b]|[\x0c]|[\x0e-\x1f])/', '', $string, -1, $cleaned_count);
		} while ($cleaned_count>0);
		return $string;
	}// /method



	/**
	 * Convert a Camel Case style string to underscores
	 *
	 * The upper/lower case of each letter is preserved.
	 * Every capital letter, except the first character, will be split by an underscore.
	 *
	 * e.g. myVariableName    => my_Variable_Name
	 * e.g. MySecondVariable  => My_Second_Variable
	 *
	 * @param  string  $string  The string to convert.
	 *
	 * @return  string  The result.
	 */
	public static function convertCamelCaseToUnderscore($string) {
		$result = '';

		$len = strlen($string);

		for($i=0; $i<$len; $i++) {
			$c = $string[$i];
			$result .= (ctype_upper($c) && ($i!=0)) ? "_{$c}" : $c ;
		}

		return $result;
	}// /method



	/**
	 * Convert an underscore style string to CamelCase.
	 *
	 * Each initial letter is capitalised, every other letter is lowercased.
	 * You can choose whether to convert the very first character to upper or lower case.
	 *
	 * e.g. my_Variable_Name  => myVariableName
	 * e.g. My_SECOND_Variable  => mySecondVariable
	 *
	 * @param  string  $string  The string to convert.
	 * @param  boolean  $capitalise_first  (optional) Automatically capitalise the first word. (default: false)
	 *
	 * @return  string  The result.
	 */
	public static function convertUnderscoreToCamelCase($string, $capitalise_first = false) {
		$result = '';

		$bits = explode('_', $string);
		if ($bits) {
			foreach($bits as $i => $bit) {
				if (strlen($bit)>0) {
					$bit = strtolower($bit);
					if ( ($i!=0) || ($capitalise_first) ) {
						$bit[0] = strtoupper($bit[0]);
					}
					$result .= $bit;
				}
			}
		}
		return $result;
	}// /method



	/**
	 * Count the number of occurences of the given substrings in the subject string.
	 *
	 * @param  string  $haystack  The string to search.
	 * @param  mixed  $needles  A single, or array of, sub-strings to search for.
	 * @param  boolean  $case_sensitive  (optional) Flag if searching should be case sensitive. (default: true)
	 *
	 * @return  integer  The occurence count.
	 */
	public static function countSubstrings($haystack, $needles, $case_sensitive = true) {
		$count = 0;
		$needles = (array) $needles;

		if ($case_sensitive) {
			foreach ($needles as $substring) {
				$count += substr_count($haystack, $substring);
			}
		} else {
			$haystack = strtolower($haystack);
			foreach ($needles as $substring) {
				$count += substr_count($haystack, strtolower($substring));
			}
		}

		return (int) $count;
	}// /method



	/**
	 * De-chunk a multi-line split string into a single string.
	 *
	 * @param  string  $str  The string to de-chunk.
	 *
	 * @return  string  The de-chunked string.
	 */
	public static function dechunkString($str) {
		$dechunked_str = '';

		while (!empty($str)) {
			$str = ltrim($str);
			$eol_pos = strpos($str, "\r\n");

			if ($eol_pos === false) {
				$dechunked_str .= $str;
				return $dechunked_str;
			} else {
				$len = hexdec(substr($str, 0, $eol_pos));
				if ( (!is_numeric($len)) || ($len<1) ) {
					$dechunked_str .= $str;
					return $dechunked_str;
				}
				$dechunked_str .= substr($str, ($eol_pos + 2), $len);
				$str = ltrim( substr($str, ($len + $eol_pos + 2)));
			}
		}

		return $dechunked_str;
	}// /method



	/**
	 * Extract a substring that matches the given regular expression.
	 *
	 * @param  string  $regex
	 * @param  string  $string
	 * @param  integer  $index  (optional) The index of the matching part to return.  (default: 0)
	 *
	 * @return  mixed  The extracted string.  On fail, null.
	 */
	public static function extractRegex($regex, $string, $index = 0) {
		if (!preg_match($regex, $string, $match)) {
			return false;
		}
		return isset($match[$index]) ? $match[$index] : null;
	}// /method



	public static function formatBytes($bytes) {
		if ($bytes < 1024) { return $bytes . 'B'; }
		elseif ($bytes < 1048576) { return round($bytes / 1024, 2) . 'KB'; }
		elseif ($bytes < 1073741824) { return round($bytes / 1048576, 2) . 'MB'; }
		elseif ($bytes < 1099511627776) { return round($bytes / 1073741824, 2) . 'GB'; }
		elseif ($bytes < 1125899906842624) { return round($bytes / 1099511627776, 2) . 'TB'; }
		else { return round($bytes / 1125899906842624, 2) .'PB'; }
	}



	/**
	 * Check if the given string is UTF-8.
	 *
	 * Regex taken from W3C page:
	 * http://w3.org/International/questions/qa-forms-utf-8.html
	 *
	 * @param  string  $string
	 *
	 * @return  boolean  The string is UTF-8.
	 */
	public static function isUtf8($string) {
		return preg_match('/^(?:
			[\x09\x0A\x0D\x20-\x7E]              # ASCII
			| [\xC2-\xDF][\x80-\xBF]             # Non-overlong 2-byte
			|  \xE0[\xA0-\xBF][\x80-\xBF]        # Excluding overlongs
			| [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}  # Straight 3-byte
			|  \xED[\x80-\x9F][\x80-\xBF]        # Excluding surrogates
			|  \xF0[\x90-\xBF][\x80-\xBF]{2}     # Planes 1-3
			| [\xF1-\xF3][\x80-\xBF]{3}          # Planes 4-15
			|  \xF4[\x80-\x8F][\x80-\xBF]{2}     # Plane 16
		)*$/xs', $string);
	}// /method



	/**
	 * Get the ordinal name of the given integer.
	 *
	 * e.g.
	 *
	 * @param  integer  $int
	 *
	 * @return  string  The ordinal value.
	 */
	public static function ordinal($int) {
		$num = (string) $int;

		$last = (int) substr($num, -1);
		$second_last = (int) substr($num, -2, -1);

		if ($last>3 || $last==0 ) { $ext = 'th'; }
		elseif ($last==3) { $ext = 'rd'; }
		elseif ($last==2) { $ext = 'nd'; }
		else { $ext = 'st'; }

		if ( ($second_last==1) && (($last>=1) || ($last<=3)) ) { $ext = 'th'; }

		return $num.$ext;
	}// /method



	/**
	 * Get the boolean representation of the given text.
	 *
	 * Checks the string for predefined boolean equivalents, and returns the appropriate boolean value.
	 * String equivalents include:
	 * true  => '1', 'yes', 'y', 'on'
	 * false => '0', 'no', 'n', 'off'
	 *
	 * If no matches are found, $default is returned.
	 *
	 * @param  string  $string
	 * @param  mixed  $default  (default: false)
	 *
	 * @return  mixed
	 */
	public static function parseBoolean($string, $default = false) {
		if (empty($string)) { return $default; }
		$string = strtolower(trim($string));
		if (in_array($string, array ('1', 'yes', 'y', 'on'))) { return true; }
		if (in_array($string, array ('0', 'no', 'n', 'off'))) { return false; }
		return $default;
	}



	/**
	 * Get the datetime representation of the given text.
	 *
	 * If $format_mdy is false, then all dates are assumed to be in european format (d/m/y).
	 * If $string is not a valid date, $default is returned.
	 *
	 * @param  string  $string
	 * @param  mixed  $default
	 * @param  boolean  $format_mdy  Use US style month-day-year format.  (default: false)
	 *
	 * @return  mixed
	 */
	public static function parseDate($string, $default, $format_mdy = false) {
		if (empty($string)) { return $default; }
		$string = trim($string);

		// strtotime uses the date separator to decide the date format
		// e.g.  x/y/z = m/d/y  while  x-y-z = d-m-y
		// We force the date format we want by changing the separator.
		if ($format_mdy) {
			$string = str_replace(array('-', '.', ' '), '/', $string);
		} else {
			$string = str_replace(array('/', '.', ' '), '-', $string);
		}

		$date = strtotime($string);
		if ( ($date === false) || ($date === -1) ) {
			return $default;
		} else {
			return $date;
		}
	}



	/**
	 * Parse a querystring style string into an assoc-array of key-value pairs.
	 *
	 * Similar to PHP's parse_str() but without the annoying key-renaming features.
	 * Keys with multiple instances or array indicators have arrays for values. e.g. k=xx&k=yy&k[]=zz  becomes  array ( k => array ( xx, yy, zz ) )
	 * Keys without values become array keys with boolean true values. e.g.  k1&k2=xxx  becomes  array ( k1 => true, k2 => xxx )
	 *
	 * Key values pairs are split using the first instance of $inner_separator.
	 *
	 * @param  string  $querystring  The string to parse.
	 * @param  string  $outer_separator (optional)  The string that separates the key-value pairs. (default: '&')
	 * @param  string  $inner_separator (optional)  The string that separates the key and value. (default: '=')
	 *
	 * @return  mixed  The resulting assoc-array. On fail, an empty array.
	 */
	public static function parseQuerystring($querystring, $outer_separator = '&', $inner_separator = '=') {

		if (empty($querystring)) { return null; }

		$kv_pairs = array();

		$pairs = explode($outer_separator, $querystring);
		if (!is_array($pairs)) { $pairs = (array) $kv_pairs; }

		foreach($pairs as $i => $pair) {
			$bits = explode($inner_separator, $pair, 2);

			if (count($bits)==2) {
				$key = $bits[0];
				$value = (strlen($bits[1])>=1) ? $bits[1] : null ;
			} else {
				$key = $pair;
				$value = true;
			}

			$key = trim($key);

			// Check and process array indicators ([])
			// @todo : parseQuerystring cannot handle assoc array parameters
			if (strpos($key, '[]')!==false) {
				$temp = strrev($key);
				if (strpos($temp, '[]')==0) {
					$key = substr($key, 0, strlen($key)-2);
					$key = trim($key);
				}
			}

			if (array_key_exists($key, $kv_pairs)) {
				if (is_array($kv_pairs[$key])) {
					$kv_pairs[$key][] = $value;
				} else {
					$kv_pairs[$key] = array ( $kv_pairs[$key], $value );
				}
			} else {
				$kv_pairs[$key] = $value;
			}
		}
		// /foreach(kv-pair)

		return $kv_pairs;
	}// /method



	/**
	 * Get a standardised representation of the given string.
	 *
	 * The string will be trimmed of whitespace, and limited to $max_length.
	 * If after trimming the string is empty, $default will be returned.
	 *
	 * @param  string  $string
	 * @param  int  $max_length
	 * @param  mixed  $default  (default: '')
	 *
	 * @return  mixed
	 */
	public static function parseString($string, $max_length, $default = '') {
		$string = substr(trim($string), 0, $max_length);
		return (empty($string)) ? $default : $string ;
	}



	/**
	 * Parse a URL into its component parts.
	 *
	 * Similar to PHP's parse_url() function, but with more information returned.
	 * This method returns port numbers for common transport schemes, even if they
	 * are not included explicitly in $url.
	 *
	 * @param  string  $url  The URL to parse.
	 *
	 * @return  mixed  Array of URL parts.  On fail, null.
	 */
	public static function parseUrl($url) {
		$url_bits = parse_url(trim($url));

		if (is_array($url_bits)) {

			// Scheme
			if (array_key_exists('scheme', $url_bits)) {
				$bits['scheme'] = $url_bits['scheme'];
			} else {
				$bits['scheme'] = null;
			}

			// Port
			if (array_key_exists('port', $url_bits)) {
				$bits['port'] = $url_bits['port'];
			} else {
				switch(strtolower($bits['scheme'])) {
					case 'ftp':
						$bits['port'] = 21;
						break;
					case 'ftps':
						$bits['port'] = 990;
						break;
					case 'https':
					case 'ssl':
						$bits['port'] = 443;
						break;
					case 'http':
					default:
						$bits['port'] = 80;
						break;
				}// /switch()
			}

			// Path
			if (array_key_exists('path', $url_bits)) {
				$bits['path'] = $url_bits['path'];
			} else {
				$bits['path'] = null;
			}

			// Host
			if (array_key_exists('host', $url_bits)) {
				$bits['host'] = $url_bits['host'];
			}

			// Query
			if (array_key_exists('query', $url_bits)) {
				$bits['query'] = $url_bits['query'];
			}

			// Fragment
			if (array_key_exists('fragment', $url_bits)) {
				$bits['fragment'] = $url_bits['fragment'];
			}

			// User
			if (array_key_exists('user', $url_bits)) {
				$bits['user'] = $url_bits['user'];
			}

			// Password
			if (array_key_exists('pass', $url_bits)) {
				$bits['pass'] = $url_bits['pass'];
			}

			return $bits;
		}// /if(bits)

		return null;
	}// /method



	/**
	 * Returns the plural version of the given noun.
	 *
	 * Only performs a simple check on the word ending.
	 * e.g.
	 * "apple" becomes "apples"   (adds 's')
	 * "country" becomes "countries"  ('???y' => '???ies')
	 *
	 * @param  string  $noun  The noun to use.
	 *
	 * @return  string  The plural form of the noun. On fail, returns $noun.
	 */
	public static function plural($noun) {
		if ( (is_string($noun)) && (!empty($noun)) ) {
			$last = strlen($noun)-1;
			if ($noun[$last]=='y') {
				$sub = substr($noun, 0, -1);
				return "{$sub}ies";
			} else {
				return "{$noun}s";
			}
		}
		return $noun;
	}// /method



	/**
	 * Returns the given noun with the appropriate ownership apostrophe usage.
	 *
	 * Only performs a simple check to see if the noun ends in an 's'.
	 * e.g.
	 * "fred" becomes "fred's"  (adds 's)
	 * "luis" becomes "luis'"   (adds ')
	 *
	 * @param  string  $noun  The noun to use.
	 *
	 * @return  string  The ownership form of the noun. On fail, returns $noun.
	 */
	public static function possessive($noun) {
		if ( (is_string($noun)) && (!empty($noun)) ) {
			$last = strlen($noun)-1;
			if ($noun[$last]=='s') {
				return "{$noun}'";
			} else {
				return "{$noun}'s";
			}
		}
		return $noun;
	}// /method



	/**
	 * Return a random string of characters, of the given length
	 *
	 * @param  integer  $length  The length of string to return.
	 * @param  string  $valid_chars  (optional) The set of characters to randomly select from. (default: CHARS_ALPHANUM set)
	 *
	 * @return  string  The string of random characters.
	 */
	public static function random($length = 8, $valid_chars = null) {
		if (is_null($valid_chars)) { $valid_chars = self::CHARS_ALPHANUM; }

		$str = '';
		$max_index = strlen($valid_chars) -1;
		while(strlen($str) < $length) {
			$str .= substr($valid_chars, mt_rand(0, $max_index) , 1);
		}
		return $str;
	}// /method()



	/**
	 * Standardise line breaks.
	 *
	 * Convert \n line breaks in to \r\n.
	 *
	 * @param  string  $string  The string to process.
	 *
	 * @return  string  The standardised string.
	 */
	public static function standardiseLineBreaks($string) {
		return preg_replace("/\r?\n/", "\r\n", $string);
	}// /method



	/**
	 * Sanitize and convert the weird characters that are pasted in when using Word.
	 *
	 * @param  string  $text
	 *
	 * @return  string  The sanitized text.
	 */
	public static function sanitizeMicrosoftWord($text) {

		$replacements = array (
			chr(130)  => '\'' ,    // Single Quote
			chr(132)  => '"' ,     // Double Quote
			chr(133)  => '...' ,   // Ellipsis
			chr(145)  => '\'' ,    // Single Quote
			chr(146)  => '\'' ,    // Single Quote
			chr(149)  => '*' ,     // Bullet
			chr(150)  => '-' ,     // Hyphen
			chr(151)  => '-' ,     // Hyphen

			chr(226).chr(128).chr(147)  => '-' ,    // Hyphen
			chr(226).chr(128).chr(153)  => '\'' ,   // Apostrophe
			chr(226).chr(128).chr(156)  => '"' ,    // Double Quote (Start)
			chr(226).chr(128).chr(157)  => '"' ,    // Double Quote (End)
			chr(226).chr(128).chr(162)  => '*' ,    // Bullet
		);

		$text = str_replace(array_keys($replacements), $replacements, $text);
		return $text;
	}// /method



	/**
	 * Return the value and suffix/unit appropriate for the given value.
	 *
	 * If you need a space between $value and the given suffix, prefix each suffix with ' '.
	 * e.g.
	 * ->getSuffixed(0, ' piece', ' pieces')  returns  '0 pieces'
	 * ->getSuffixed(1, ' piece', ' pieces')  returns  '1 piece'
	 * ->getSuffixed(5, ' piece', ' pieces')  returns  '5 pieces'
	 *
	 * @param  mixed  $value  The numeric value to test.
	 * @param  string  $singular_suffix  The singular form of the suffix/units (for value = 1 or -1).
	 * @param  string  $plural_suffix  The plural form of the suffix/units, for all other values of $value.
	 *
	 * @return  string  The appropriate string unit.
	 */
	public static function suffixed($value, $singular_suffix, $plural_suffix) {
		if (is_null($value)) { $value = 0; }
		return $value . ( ( ($value===1) OR ($value===-1) ) ? $singular_suffix : $plural_suffix );
	}// /method



	/**
	 * Tokenize a quoted string.
	 *
	 * Splits a search-style string into individual tokens while respecting quotes.
	 * e.g.
	 * 'keyword "search phrase" anotherkey'  returns  array ('keyword', 'search phrase', 'anotherkey')
	 *
	 * @param  string  $string  The string to process.
	 * @param  integer  $min_token_length  (optional) Minimum token length.  Smaller tokens are ignored. (default: 0)
	 *
	 * @return  mixed  An array of tokens found. On fail, null.
	 */
	public static function tokenizeQuoted($string, $min_token_length = 0) {
		if (empty($string)) { return null; }

		$string = trim($string);
		$str_len = strlen($string);

		$tokens = array();
		$token_length = 0;
		$str_dummy = '';
		$c_end = ' ';
		$in_quote = false;

		for ($i=0;$i<$str_len;++$i) {
			if ( ($string[$i]=='"') && (!$in_quote) ) {
				$c_end = '"';
				$in_quote = true;
			} else {
				if ($string[$i]==$c_end) {
					if ($token_length>=$min_token_length) {
						$arr_tokens[] = trim($str_dummy);
						$str_dummy = '';
					}
					$token_length = 0;
					$in_quote = false;
					$c_end = ' ';
					$str_dummy = '';
				} else {
					$str_dummy .= $string[$i];
					++$token_length;
				}
			}
		}

		if (!empty($str_dummy)) { $arr_tokens[] = $str_dummy; }
		return $arr_tokens;
	}// /method



	/**
	 * Scans the querystring portion of a URL, and encodes any invalid characters in the values given.
	 *
	 * Any invalid characters in the domain, path or fragment portions (etc) are left untouched.
	 *
	 * @param  string  $url  The URL to encode.
	 *
	 * @return  string  The resultant URL.
	 */
	public static function urlEncodeQuerystring($url) {

	    if (strpos($url, '?') === false) {
	        return $url;
	    } else {
	    	$url_bits = parse_url($url);

	    	if ( (!array_key_exists('query', $url_bits)) || (empty($url_bits['query'])) ) {
	    		return $url;
	    	} else {
	    		parse_str($url_bits['query'], $kv_pairs);

	    		$qs = array();

	    		if (is_array($kv_pairs)) {
	    			foreach($kv_pairs as $k => $v) {
	    				$qs[] = $k .'='.urlencode($v);
	    			}
	    		}

	    		$url_bits['query'] = implode('&', $qs);

	    		$url = self::buildUrl($url_bits);
	    	}
	    }
	    return $url;
	}// /method



	/**
	 * Unfold a multi-line split string, such as an HTTP or Mail header, in to a single line
	 *
	 * @param  string  $text  The text to unfold.
	 *
	 * @return  string  The resulting string.
	 */
	public function unfold($text) {
		return preg_replace('/\r\n(\t| )+/', ' ', $text);
	}// /method



	/**
	 * Generate a UUID v4 Unique Identifier.
	 *
	 * Strings produced confirm to the UUID v4 format (char 14 = '4', char 18 = ['8'|'9'|'a'|'b']).
	 * e.g.  '01234567-89ab-4def-8123-456789abcdef'
	 *
	 * @return  string  The new UUID
	 */
	public static function uuid() {
		// Get random 32-char 'UUID'
		$uuid_32 = strtolower( md5( uniqid( rand(), true) ) );

		// Get the restricted char
		$r_valid = array ('8', '9', 'a', 'b');
		$r = $r_valid[rand(0, 3)];

		// Apply both the restricted chars
		$uuid_32[12] = '4';
		$uuid_32[16] = $r;

		// Convert to the correct 'dashed' format, and return the UUID
		//return preg_replace('#([\da-f]{8})([\da-f]{4})([\da-f]{4})([\da-f]{4})([\da-f]{12})#', "\\1-\\2-\\3-\\4-\\5", $uuid_32);
		return preg_replace('#([\da-f]{8})([\da-f]{4})([\da-f]{4})([\da-f]{4})([\da-f]{12})#', "\\1-\\2-\\3-\\4-\\5", $uuid_32);
	}// /method



	/**
	 * Return $subject cut to the given number of characters at a word boundary (Only ' ').
	 *
	 * Use $replace_str to define what to cut the string with.
	 * The cut happens at the next space character (' ') following the given length.
	 *
	 * @param  string  $subject  The string to be cut.
	 * @param  integer  $length  The length of line wanted.
	 * @param  string  $replace_str  (optional) The string to insert at the cut (e.g.  "\n", or '<br />'). (default: ' ')
	 *
	 * @return  string  The resulting string.
	 */
	public static function wordCut($subject, $length, $replace_str = '') {
		if ( strlen($subject)>$length ) {
			$pos = strpos($subject, ' ', $length);
			if ($pos) {	$subject = substr($subject, 0, $pos+1) . $replace_str;	}
		}
		return $subject;
	}// /method



	/**
	 * Filter out any non-matching characters.
	 *
	 * @param  string  $string  The string to test.
	 * @param  string  $valid_chars  (optional) The set of valid characters to check against. (default: CHARS_COMMON set)
	 * @param  string  $replacement  (optional) The character to replace any invalid chars wtih. (default: '')
	 *
	 * @return  string  The resulting string.
	 */
	public static function whitelistChars($string, $valid_chars = null, $replacement = '') {

		if (!$valid_chars) { $valid_chars = self::CHARS_COMMON; }

		$str_length = strlen($string);
		$str_length--;

		$new_string = '';

		if (empty($replacement)) {
			for($i=0; $i<=$str_length; ++$i) {
				if (strstr($valid_chars, $string[$i])!==false) {
					$new_string .= $string[$i];
				}
			}
		} else {
			for($i=0; $i<=$str_length; ++$i) {
				if (strstr($valid_chars, $string[$i])===false) {
					$new_string .= $replacement;
				} else {
					$new_string .= $string[$i];
				}
			}
		}
		return $new_string;
	}// /method



}// /class
?>
